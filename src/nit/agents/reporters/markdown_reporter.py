"""Markdown reporter â€” generates Markdown test reports.

Produces human-readable Markdown reports from nit's pipeline results,
suitable for documentation, wikis, and PR descriptions.
"""

from __future__ import annotations

import logging
from datetime import UTC, datetime
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from pathlib import Path

from nit.adapters.base import CaseStatus, RunResult

logger = logging.getLogger(__name__)


class MarkdownReporter:
    """Generate Markdown reports from pipeline results."""

    def generate(
        self,
        output_path: Path,
        *,
        test_result: RunResult | None = None,
        extra: dict[str, Any] | None = None,
    ) -> Path:
        """Write a Markdown report file.

        Args:
            output_path: Path to write the Markdown file.
            test_result: Aggregated test run result.
            extra: Additional pipeline data.

        Returns:
            The path to the generated Markdown file.
        """
        content = self.generate_string(test_result=test_result, extra=extra)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(content, encoding="utf-8")
        logger.info("Markdown report written to %s", output_path)
        return output_path

    def generate_string(
        self,
        *,
        test_result: RunResult | None = None,
        extra: dict[str, Any] | None = None,
    ) -> str:
        """Return Markdown report as a string.

        Args:
            test_result: Aggregated test run result.
            extra: Additional pipeline data.

        Returns:
            Markdown content as a string.
        """
        sections: list[str] = []

        sections.append("# nit Test Report\n")
        sections.append(f"Generated: {datetime.now(tz=UTC).strftime('%Y-%m-%d %H:%M:%S UTC')}\n")

        if test_result is not None:
            sections.append(_render_summary(test_result))
            if test_result.test_cases:
                sections.append(_render_test_cases(test_result))

        if extra:
            for key, value in extra.items():
                sections.append(f"\n## {key.replace('_', ' ').title()}\n")
                if isinstance(value, dict):
                    sections.extend(f"- **{k}**: {v}" for k, v in value.items())
                elif isinstance(value, list):
                    sections.extend(f"- {item}" for item in value)
                else:
                    sections.append(str(value))
                sections.append("")

        sections.append("\n---\n*Generated by [nit](https://getnit.dev)*\n")

        return "\n".join(sections)


def _render_summary(result: RunResult) -> str:
    """Render the test summary section."""
    status_icon = "PASS" if result.success else "FAIL"
    lines = [
        "\n## Summary\n",
        f"**Status**: {status_icon}\n",
        "| Metric | Count |",
        "|--------|-------|",
        f"| Total | {result.total} |",
        f"| Passed | {result.passed} |",
        f"| Failed | {result.failed} |",
        f"| Skipped | {result.skipped} |",
        f"| Errors | {result.errors} |",
        f"| Duration | {result.duration_ms / 1000:.2f}s |",
        "",
    ]
    return "\n".join(lines)


def _render_test_cases(result: RunResult) -> str:
    """Render the test cases section."""
    lines = ["\n## Test Cases\n"]

    # Show failures first
    failures = [tc for tc in result.test_cases if tc.status == CaseStatus.FAILED]
    if failures:
        lines.append("### Failures\n")
        for tc in failures:
            lines.append(f"- **{tc.name}**")
            if tc.file_path:
                lines.append(f"  - File: `{tc.file_path}`")
            if tc.failure_message:
                msg = tc.failure_message[:200]
                lines.append(f"  - Error: {msg}")
            lines.append("")

    # Show errors
    errors = [tc for tc in result.test_cases if tc.status == CaseStatus.ERROR]
    if errors:
        lines.append("### Errors\n")
        for tc in errors:
            lines.append(f"- **{tc.name}**")
            if tc.failure_message:
                lines.append(f"  - Error: {tc.failure_message[:200]}")
            lines.append("")

    # Summary table of all cases
    lines.append("### All Tests\n")
    lines.append("| Status | Test | Duration |")
    lines.append("|--------|------|----------|")
    for tc in result.test_cases:
        status = _status_label(tc.status)
        lines.append(f"| {status} | {tc.name} | {tc.duration_ms:.0f}ms |")
    lines.append("")

    return "\n".join(lines)


def _status_label(status: CaseStatus) -> str:
    """Map test status to a Markdown label."""
    labels: dict[CaseStatus, str] = {
        CaseStatus.PASSED: "PASS",
        CaseStatus.FAILED: "FAIL",
        CaseStatus.SKIPPED: "SKIP",
        CaseStatus.ERROR: "ERR",
    }
    return labels.get(status, "?")
